<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Cantotype</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"/>
    
    <!-- Main style sheet -->
    <style>

@font-face {
  font-family: 'FreeHK';
  font-style: normal;
  font-weight: normal;
  src: url('freehk.woff');
}

@font-face {
  font-family: 'NotoSansHK';
  font-style: normal;
  font-weight: normal;
  src: url('notosanshk.woff');
}

@font-face {
  font-family: 'LastResort';
  font-style: normal;
  font-weight: normal;
  src: url('lastresort.woff');
}

body {
  padding-left: 0.25em;
  padding-right: 0.25em;
  margin-bottom: 3.5em;
  background-color: WhiteSmoke;
  color: black;
  font-family: sans-serif;
}

:link {
  text-decoration: none;
  color: blue
}

:visited {
  text-decoration: none;
  color: blue
}

#divSplash {
  font-style: italic;
}

#divMain {
  display: none;
}

#tblCtl td {
  padding-left: 0.25em;
  padding-right: 0.25em;
  padding-top: 0.25em;
  padding-bottom: 0.25em;
}

#txtInput {
  font-family: monospace;
  max-width: 10em;
}

.clsNotes {
  background-color: white;
  max-width: 35em;
  padding: 0.5em;
  border: thin solid;
  margin-top: 1em;
  margin-bottom: 1em;
}

#tblApos {
  border-collapse: collapse;
}

#tblApos th {
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  padding-left: 1em;
  padding-right: 1em;
  border: thin solid;
  text-align: center;
  font-weight: bold;
}

#tblApos td {
  padding-top: 0.25em;
  padding-bottom: 0.25em;
  padding-left: 1em;
  padding-right: 1em;
  border: thin solid;
}

.tdAposCode {
  text-align: center;
  font-family: monospace;
}

.tdAposResult {
  text-align: center;
}

.tdAposMeaning {
  text-align: left;
}

.rtable td {
  padding-left: 0.25em;
  padding-right: 0.25em;
}

.han {
  font-family: 'FreeHK', 'NotoSansHK', 'LastResort', sans-serif;
  font-size: 400%;
}

.hanquote {
  font-family: 'FreeHK', 'NotoSansHK', 'LastResort', sans-serif;
}

.cpt {
  font-family: monospace;
  font-size: 150%;
}

.cpr {
  font-weight: bold;
}

.cpd {
  font-style: italic;
}

.tt {
  font-family: monospace;
}

#txtWrite {
  font-family: 'FreeHK', 'NotoSansHK', 'LastResort', sans-serif;
  font-size: 150%;
}

#txtCode {
  font-family: monospace;
  font-size: 120%;
}

.clsLine {
  margin-top: 1em;
  margin-bottom: 1em;
}

#divErrLine {
  display: none;
  margin-top: 1em;
  margin-bottom: 1em;
  font-weight: bold;
  color: red;
}

    </style>
    
    <!-- If JavaScript disabled, do not show the splash screen -->
    <noscript>
      <style>

#divSplash {
  display: None;
}

      </style>
    </noscript>
    
    <!-- Load HKSCS table into canto_table -->
    <script src="cantotype_table.js"></script>
    
    <!-- Embedded script is for presentation tier functionality -->
    <script>

// Wrap everything in an anonymous function that we immediately invoke
// after it is declared -- this prevents anything from being implicitly
// added to global scope
(function() {

  /*
   * Constants
   * =========
   */
  
  /*
   * All the valid Yale initials, each surrounded by colons.
   */
  var VALID_INITIALS = ":b:p:m:f:d:t:n:l:g:k:ng:h:gw:kw:w:j:ch:s:y:";

  /*
   * Local data
   * ==========
   */
  
  /*
   * Codepoint to readings table.
   *
   * The property keys are decimal representations of the codepoints.
   *
   * The property values are arrays that store all Jyutping reads of
   * that codepoint.
   *
   * This table is generated during handleLoad() by loadReadings().
   */
  var m_readings;

  /*
   * Local functions
   * ===============
   */
  
  /*
   * Report an error to console and throw an exception for a fault
   * occurring within this module.
   *
   * Parameters:
   *
   *   func_name : string - the name of the function in this module
   *
   *   loc : number(int) - the location within the function
   */
  function fault(func_name, loc) {
    
    // If parameters not valid, set to unknown:0
    if ((typeof func_name !== "string") || (typeof loc !== "number")) {
      func_name = "unknown";
      loc = 0;
    }
    loc = Math.floor(loc);
    if (!isFinite(loc)) {
      loc = 0;
    }
    
    // Report error to console
    console.log("Fault at " + func_name + ":" + String(loc) +
                  " in ctt_html");
    
    // Throw exception
    throw ("ctt_html:" + func_name + ":" + String(loc));
  }

  /*
   * Escape a string if necessary so that it can be included within
   * HTML markup.
   *
   * This first escapes & as &amp;, and then escapes < as &lt; and > as
   * &gt;
   *
   * Parameters:
   *
   *   str : string - the string to escape
   *
   * Return:
   *
   *   the escaped string
   */
  function htmlEsc(str) {
    
    var func_name = "htmlEsc";
    
    // Check parameter
    if (typeof str !== "string") {
      fault(func_name, 100);
    }
    
    // Replace ampersand
    str = str.replace(/&/g, "&amp;");
    
    // Replace markup characters
    str = str.replace(/</g, "&lt;");
    str = str.replace(/>/g, "&gt;");
    
    // Return escaped string
    return str;
  }

  /*
   * Load m_readings using the canto_table global.
   */
  function loadReadings() {
    
    var r, i;
    var cpa, cpv;
    
    // Set the readings variable to an empty object
    m_readings = {};
    
    // Go through all readings in the canto_table
    for(r in canto_table) {
      
      // Get all codepoints for this reading
      cpa = canto_table[r];
      
      // Add all codepoint-to-reading mappings
      for(i = 0; i < cpa.length; i++) {
        // Get codepoint value
        cpv = cpa[i];
        
        // Convert to integer string
        cpv = cpv.toString(10);
        
        // If not yet defined in readings, add empty array
        if (!(cpv in m_readings)) {
          m_readings[cpv] = [];
        }
        
        // Add this reading to the codepoint
        m_readings[cpv].push(r);
      }
    }
  }
  
  /*
   * Return the character index of the last character in the string that
   * is a combining acute accent, combining grave accent, or combining
   * macron, or return -1 if no such characters remain.
   *
   * Parameters:
   *
   *   str : string - the string to search
   *
   * Return:
   *
   *   the index of the last such character, or -1
   */
  function lastDiacritic(str) {
    
    var func_name = "lastDiacritic";
    var lastG, lastA, lastM;
    var m;
    
    // Check parameter
    if (typeof str !== "string") {
      fault(func_name, 100);
    }
    
    // Figure out the last index of each relevant diacritic
    lastG = str.lastIndexOf(String.fromCharCode(0x0300));
    lastA = str.lastIndexOf(String.fromCharCode(0x0301));
    lastM = str.lastIndexOf(String.fromCharCode(0x0304));
    
    // Get the maximum value
    m = lastG;
    if (lastA > m) {
      m = lastA;
    }
    if (lastM > m) {
      m = lastM;
    }
    
    // Return the last index or -1
    return m;
  }
  
  /*
   * Return the character index of the last vowel in the string, or
   * return -1 if no vowels remain.
   *
   * Y is not considered a vowel by this function.
   *
   * Parameters:
   *
   *   str : string - the string to search
   *
   * Return:
   *
   *   the index of the last such character, or -1
   */
  function lastVowel(str) {
    
    var func_name = "lastVowel";
    var lastA, lastE, lastI, lastO, lastU;
    var m;
    
    // Check parameter
    if (typeof str !== "string") {
      fault(func_name, 100);
    }
    
    // Figure out the last index of each vowel
    lastA = str.lastIndexOf("a");
    lastE = str.lastIndexOf("e");
    lastI = str.lastIndexOf("i");
    lastO = str.lastIndexOf("o");
    lastU = str.lastIndexOf("u");
    
    // Get the maximum value
    m = lastA;
    if (lastE > m) {
      m = lastE;
    }
    if (lastI > m) {
      m = lastI;
    }
    if (lastO > m) {
      m = lastO;
    }
    if (lastU > m) {
      m = lastU;
    }
    
    // Return the last index or -1
    return m;
  }
  
  /*
   * Return the character index of the first vowel in the string, or
   * return -1 if no vowels remain.
   *
   * Y is not considered a vowel by this function.
   *
   * Parameters:
   *
   *   str : string - the string to search
   *
   * Return:
   *
   *   the index of the first such character, or -1
   */
  function firstVowel(str) {
    
    var func_name = "firstVowel";
    var firstA, firstE, firstI, firstO, firstU;
    var m;
    
    // Check parameter
    if (typeof str !== "string") {
      fault(func_name, 100);
    }
    
    // Figure out the first index of each vowel
    firstA = str.indexOf("a");
    firstE = str.indexOf("e");
    firstI = str.indexOf("i");
    firstO = str.indexOf("o");
    firstU = str.indexOf("u");
    
    // Get the minimum value, but -1 is larger than everything
    m = firstA;
    if ((m === -1) || ((firstE !== -1) && (firstE < m))) {
      m = firstE;
    }
    if ((m === -1) || ((firstI !== -1) && (firstI < m))) {
      m = firstI;
    }
    if ((m === -1) || ((firstO !== -1) && (firstO < m))) {
      m = firstO;
    }
    if ((m === -1) || ((firstU !== -1) && (firstU < m))) {
      m = firstU;
    }
    
    // Return the first index or -1
    return m;
  }
  
  /*
   * Given user input typed into the search box, return an array
   * containing integer values of all codepoints to display.
   *
   * The returned array may be empty if nothing matches.
   *
   * Parameters:
   *
   *   str : string - the query string
   *
   * Return:
   *
   *   array containing all matching codepoints as integer values
   */
  function doQuery(str) {
    
    var func_name = "doQuery";
    var c, i;
    var sa, sb, sc;
    var f, nt, m, t;
    var fvi, lvi, ab, af;
    var ra1, ra2;
    
    // Check parameter
    if (typeof str !== "string") {
      fault(func_name, 100);
    }
    
    // First of all, trim leading and trailing whitespace and normalize
    // to NFC
    str = str.trim().normalize("NFC");
    
    // If string is empty after trimming, return empty array
    if (str.length < 1) {
      return [];
    }
    
    // Get the first codepoint of string
    c = str.codePointAt(0);
    
    // Check whether this string has a single codepoint above U+007F AND
    // the NFD decomposition of that codepoint does not begin with a
    // Latin letter; if this is the case, return an array with just that
    // codepoint
    if (c > 0x7f) {
      // Check whether we have a single codepoint in the string
      // (remember that supplemental codepoints take two characters)
      if ((c < 0x10000) && (str.length === 1)) {
        i = true;
      } else if (str.length === 2) {
        i = true;
      } else {
        i = false;
      }
      
      // If single extended codepoint, check whether NFD decomposition
      // begins with an ASCII letter; if it does not, then return a
      // result just of the given codepoint
      if (i) {
        sa = str.normalize("NFD");
        if (sa.length > 0) {
          c = sa.charCodeAt(0);
          if (((c < 0x41) || (c > 0x5a)) &&
              ((c < 0x61) || (c > 0x7a))) {
            return [c];
          }
        }
      }
    }
    
    // Handle Unicode literal
    if ((/^u[0-9a-f]{4,6}$/i).test(str)) {
      // We have a literal string, so begin by dropping the leading "u"
      // character
      str = str.slice(1);
      
      // Get the integer value of the base-16 number
      c = parseInt(str, 16);
      
      // Return just that value if it is in Unicode range, beyond ASCII
      // range, and not a surrogate, else return empty array
      if ((c > 0x7f) && (c <= 0x10ffff) && 
            ((c < 0xd800) || (c > 0xdfff))) {
        return [c];
        
      } else {
        return [];
      }
    }
    
    // Otherwise, if there is a decimal integer somewhere in the value,
    // handle Jyutping
    if ((/[0-9]/).test(str)) {
      
      // Make lowercase
      str = str.toLowerCase();
      
      // If format basically correct, look up; else, return nothing
      if ((/^[a-z]+[1-6]$/).test(str)) {
        if (str in canto_table) {
          // Return copy of array
          return canto_table[str].map(x => x);
        } else {
          return [];
        }
      } else {
        return [];
      }
    }
    
    // If we got here, we should assume Yale; begin by decomposing to
    // NFD form
    str = str.normalize("NFD");
    
    // Change all combining circumflex marks to combining macrons
    str = str.replace(/\u0302/g, String.fromCharCode(0x0304));
    
    // Change all left single quotes and right single quotes to ASCII
    // apostrophes
    str = str.replace(/\u02018/g, "'");
    str = str.replace(/\u02019/g, "'");
    
    // Process all combining grave accents, acute accents, and macrons
    // starting from end of string to beginning, checking that they are
    // only used immediately behind an ASCII letter (returning no
    // results if not) and then replacing them with the appropriate
    // apostrophe escape code around the letter
    for(i = lastDiacritic(str); i >= 0; i = lastDiacritic(str)) {
      
      // If last diacritic is very first character, then this is not
      // valid so return no results
      if (i === 0) {
        return [];
      }
      
      // Last diacritic must be preceded by an ASCII letter, or else it
      // is not valid so return no results
      c = str.charCodeAt(i - 1);
      if (((c < 0x41) || (c > 0x5a)) && ((c < 0x61) || (c > 0x7a))) {
        return [];
      }
      
      // Get the string before the previous character, the previous
      // character, the codepoint of this diacritic, and everything
      // after this diacritic
      if (i > 1) {
        sa = str.slice(0, i - 1);
      } else {
        sa = "";
      }
      
      sb = str.charAt(i - 1);
      c = str.charCodeAt(i);
      
      if (i < str.length - 1) {
        sc = str.slice(i + 1);
      } else {
        sc = "";
      }
      
      // Remove the diacritic and insert the appropriate apostrophes
      // around the letter that precedes it
      if (c === 0x0300) {
        // Grave accent
        str = sa + "'" + sb + sc;
        
      } else if (c === 0x0301) {
        // Acute accent
        str = sa + sb + "'" + sc;
        
      } else if (c === 0x0304) {
        // Macron
        str = sa + "'" + sb + "'" + sc;
        
      } else {
        // Shouldn't happen
        fault(func_name, 200);
      }
    }
    
    // Now that we have reduced diacritics to apostrophes and handled
    // all substitutions, we can make everything lowercase
    str = str.toLowerCase();
    
    // The only thing that should be left in the string at this point is
    // lowercase ASCII letters and apostrophes; if anything else, string
    // is not valid so return no results in that case
    if (!((/^[a-z']+$/).test(str))) {
      return [];
    }
    
    // First we want to completely handle the case where there are no
    // vowels aeiou anywhere, which can only validly happen when there
    // is a syllabic m or ng nasal
    if (!((/[aeiou]/).test(str))) {
      
      // Look at the end of the string to figure out what syllabic nasal
      // we have and get the final; if we don't have a valid final,
      // return nothing
      m = str.match(/('?m'?h?|n'?g'?h?)$/);
      if (m == null) {
        return [];
      }
      
      // Split into initial and final
      if (m.index > 0) {
        nt = str.slice(0, m.index);
      } else {
        nt = "";
      }
      
      f = str.slice(m.index);
      
      // Check that initial is recognized (if not empty), returning no
      // results if not
      if (nt.length > 0) {
        if (VALID_INITIALS.indexOf(":" + nt + ":") < 0) {
          return [];
        }
      }
      
      // Transform initial to Jyutping
      if (nt === "y") {
        nt = "j";
      } else if (nt === "j") {
        nt = "z";
      } else if (nt === "ch") {
        nt = "c";
      }
      
      // Make sure we don't have the invalid combination of macron with
      // low marker h
      if ((f === "'m'h") || (f === "n'g'h")) {
        return [];
      }
      
      // Replace macron with grave accent
      f = f.replace(/'(m|g)'/g, "'$1");
      
      // If final ends with low marker h, start tone at 6 and remove
      // marker; else, start tone at 3
      if ((/h$/).test(f)) {
        t = 6;
        f = f.slice(0, -1);
      } else {
        t = 3;
      }
      
      // If there is an apostrophe, adjust tone marker and remove the
      // apostrophe
      if ((/'(m|g)/).test(f)) {
        // Grave accent
        t = t - 2;
      
      } else if ((/(m|g)'/).test(f)) {
        // Acute accent
        t = t - 1;
      }
      
      f = f.replace(/'/g, "");
      
      // Now assemble the Jyutping romanization
      str = nt + f + t.toString(10);
      
      // Recursively call this function again with the Jyutping
      return doQuery(str);
    }
    
    // Get indices of first non-Y vowel and last non-Y vowel in string
    fvi = firstVowel(str);
    lvi = lastVowel(str);

    // Should be at least one vowel at this point because we handled the
    // case of no vowels earlier
    if ((fvi === -1) || (lvi === -1)) {
      fault(func_name, 300);
    }
    
    // Figure out whether there is an apostrophe before and/or after the
    // first vowel
    ab = false;
    af = false;
    
    if (fvi > 0) {
      if (str.charAt(fvi - 1) === "'") {
        ab = true;
      }
    }
    
    if (fvi < str.length - 1) {
      if (str.charAt(fvi + 1) === "'") {
        af = true;
      }
    }
    
    // Drop the apostrophes that surround the initial vowel and adjust
    // fvi/lvi if necessary
    if (ab) {
      if (fvi > 1) {
        str = str.slice(0, fvi - 1) + str.slice(fvi);
      } else {
        str = str.slice(1);
      }
      fvi--;
      lvi--;
    }
    
    if (af) {
      if (fvi + 2 >= str.length) {
        str = str.slice(0, -1);
      } else {
        str = str.slice(0, fvi + 1) + str.slice(fvi + 2);
      }
      if (lvi > fvi) {
        lvi--;
      }
    }
    
    // If an "h" after the last vowel, then begin tone at 6, while
    // otherwise begin tone at 3; remove marker h if present
    if (lvi < str.length - 1) {
      if (str.charAt(lvi + 1) === "h") {
        t = 6;
        if (lvi + 2 >= str.length) {
          str = str.slice(0, -1);
        } else {
          str = str.slice(0, lvi + 1) + str.slice(lvi + 2);
        }
        
      } else {
        t = 3;
      }
      
    } else {
      t = 3;
    }
    
    // Adjust tone based on apostrophes that surrounded the initial
    // vowel
    if (ab && af) {
      // Both sides so macron -- make sure we are not currently at tone
      // six, which can't use macron, and return nothing if that is the
      // case
      if (t === 6) {
        return [];
      }
      
      // Macron equivalent in Jyutping to grave accent
      t = t - 2;
      
    } else if (ab) {
      // Apostrophe before so grave accent
      t = t - 2;
      
    } else if (af) {
      // Apostrophe after so acute accent
      t = t - 1;
    }
    
    // We now got the Jyutping tone number and dropped apostrophes and
    // the h marker -- make sure no apostrophes remain
    if (str.indexOf("'") !== -1) {
      return [];
    }
    
    // If the first vowel is a "u" that is preceded by a "y", move the
    // first vowel index back one so that it points to the "y"
    if ((str.charAt(fvi) === "u") && (fvi > 0)) {
      if (str.charAt(fvi - 1) === "y") {
        fvi--;
      }
    }
    
    // Split into initial and final, with final starting on first vowel
    if (fvi > 0) {
      nt = str.slice(0, fvi);
    } else {
      nt = "";
    }
    
    f = str.slice(fvi);

    // Make sure initial is allowed, if present
    if (nt.length > 0) {
      if (VALID_INITIALS.indexOf(":" + nt + ":") < 0) {
        return [];
      }
    }
    
    // Make sure we don't have a "y" initial followed by a final that
    // starts with "yu"
    if ((nt === "y") && ((/^yu/).test(f))) {
      return [];
    }
    
    // Transform initial to Jyutping
    if (nt === "y") {
      nt = "j";
    } else if (nt === "j") {
      nt = "z";
    } else if (nt === "ch") {
      nt = "c";
    }
    
    // If initial is empty and final starts with "yu" then insert "j"
    // as the initial
    if ((nt.length < 1) && ((/^yu/).test(f))) {
      nt = "j";
    }
    
    // If final is just "a" then change to Jyutping "aa"
    if (f === "a") {
      f = "aa";
    }
    
    // If final begins with "eu" then change to "oe" or "eo" depending
    // on what follows
    if ((/^eu/).test(f)) {
      // For eui, eun, eut change to eo, else change to oe
      if ((/^eu[int]$/).test(f)) {
        f = "eo" + f.slice(2);
      } else {
        if (f.length > 2) {
          f = "oe" + f.slice(2);
        } else {
          f = "oe";
        }
      }
    }
    
    // Get the Jyutping version
    str = nt + f + t.toString(10);
    
    // Recursive handling
    if ((/^jyu/).test(str)) {
      // Jyutping starts with "jyu" but Yale romanization conversion is
      // ambiguous because it could also be for "ju" in Jyutping;
      // recursively try both possibilities
      ra1 = doQuery(str);
      ra2 = doQuery("j" + str.slice(2));
      
      // Merge both results and return them
      return ra1.concat(ra2);
      
    } else {
      // No possibility of ambiguity, so recursively invoke with the
      // Jyutping
      return doQuery(str);
    }
  }

  /*
   * Public functions
   * ================
   */

  /*
   * Find the element with the given ID and set its display property to
   * "block" to show it.
   *
   * Assumes that the element is properly displayed with "block".
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to show
   */
  function appear(elid) {
    
    var func_name = "appear";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Show the element
    e.style.display = "block";
  }

  /*
   * Find the element with the given ID and set its display property to
   * "none" to hide it.
   *
   * Parameters:
   *
   *   elid : string - the ID of the element to hide
   */
  function dismiss(elid) {
    
    var func_name = "dismiss";
    var e;
    
    // Check parameter
    if (typeof elid !== "string") {
      fault(func_name, 100);
    }
    
    // Get the element
    e = document.getElementById(elid);
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Hide the element
    e.style.display = "none";
  }

  /*
   * Event handler for generated links from codepoint numbers that
   * should automatically type the character into the typing box.
   */
  function typeChar(c) {
    
    var func_name = "typeChar";
    var e, si, str;
    
    // Check parameter
    if (typeof(c) !== "number") {
      fault(func_name, 100);
    }
    if (!isFinite(c)) {
      fault(func_name, 101);
    }
    c = Math.floor(c);
    if ((c < 0) || (c > 0x10ffff) ||
          ((c >= 0xd800) && (c <= 0xdfff))) {
      fault(func_name, 102);
    }
    
    // Ignore call if character is zero nul
    if (c === 0) {
      return;
    }
    
    // Convert character to string
    c = String.fromCodePoint(c);
    
    // Look up the typing box
    e = document.getElementById("txtWrite");
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Get the index of the character that follows the input cursor, or
    // the first character in the selected text if there is a selection
    // if the typing box
    si = e.selectionStart;

    // If this index is not an number, set it to -1
    if (typeof si !== "number") {
      si = -1;
    }
    
    // Floor the index to an integer
    si = Math.floor(si);
    
    // If not in range (including character index that would come after
    // everything that has been typed), set to end of range
    if ((si < 0) || (si > e.value.length)) {
      si = e.value.length;
    }
    
    // Get the string in the box
    str = e.value;
    
    // Divide string into prefix and suffix
    if (si > 0) {
      prefix = str.slice(0, si);
    } else {
      prefix = "";
    }
    
    if (si < str.length) {
      suffix = str.slice(si);
    } else {
      suffix = "";
    }
    
    // Insert the new codepoint
    str = prefix + c + suffix;
    
    // Update the typing box and move cursor to end of entered text
    e.value = str;
    e.setSelectionRange(si + c.length, si + c.length);
  }

  /*
   * Event handler for when the "append" button is clicked with the
   * codepoint box.
   */
  function handleCodebox() {
    
    var func_name = "handleCodebox";
    var e, str, sa, cps, found_err, x, c, si;
    var prefix, suffix;
    
    // Begin by hiding the error box if shown
    dismiss("divErrLine");
    
    // Get the codebox element
    e = document.getElementById("txtCode");
    if (e == null) {
      fault(func_name, 100);
    }
    
    // Get the value of the codebox string
    str = e.value;
    
    // Start with empty codepoint string
    cps = "";
    
    // Split codebox string using space, tab, and line break as
    // delimiter
    sa = str.split(/[ \t\r\n]+/);
    
    // Add all codepoints to the codepoint string
    found_err = false;
    for(x = 0; x < sa.length; x++) {
      // Get current codepoint element
      c = sa[x];
      
      // If current codepoint element is empty, skip it
      if (c.length < 1) {
        continue;
      }
      
      // Make sure we got a sequence of 1-6 hex digits
      if (!((/^[0-9A-Fa-f]{1,6}$/).test(c))) {
        found_err = true;
        break;
      }
      
      // Convert to numeric value
      c = parseInt(c, 16);
      
      // Check that Unicode codepoint range, not nul, and not surrogate
      if ((c < 1) || (c > 0x10ffff) || 
            ((c >= 0xd800) && (c <= 0xdfff))) {
        found_err = true;
        break;
      }
      
      // Add to codepoint string
      cps = cps + String.fromCodePoint(c);
    }
    
    // Check for error
    if (found_err) {
      appear("divErrLine");
      return;
    }
    
    // Ignore if nothing to add
    if (cps.length < 1) {
      return;
    }
    
    // If we got here successfully, look up the typing box
    e = document.getElementById("txtWrite");
    if (e == null) {
      fault(func_name, 200);
    }
    
    // Get the index of the character that follows the input cursor, or
    // the first character in the selected text if there is a selection
    // if the typing box
    si = e.selectionStart;
    
    // If this index is not an number, set it to -1
    if (typeof si !== "number") {
      si = -1;
    }
    
    // Floor the index to an integer
    si = Math.floor(si);
    
    // If not in range (including character index that would come after
    // everything that has been typed), set to end of range
    if ((si < 0) || (si > e.value.length)) {
      si = e.value.length;
    }
    
    // Get the string in the box
    str = e.value;
    
    // Divide string into prefix and suffix
    if (si > 0) {
      prefix = str.slice(0, si);
    } else {
      prefix = "";
    }
    
    if (si < str.length) {
      suffix = str.slice(si);
    } else {
      suffix = "";
    }
    
    // Insert the new codepoint string
    str = prefix + cps + suffix;
    
    // Update the typing box and move cursor to end of entered text
    e.value = str;
    e.setSelectionRange(si + cps.length, si + cps.length);
  }

  /*
   * Event handler for when the query button is clicked.
   */
  function handleQuery() {
    
    var func_name = "handleQuery";
    var e, eResult;
    var q, i, j, k, str, ra, m, cpa, cps, rra, cph;
    
    // Get the result DIV
    eResult = document.getElementById("divResults");
    if (eResult == null) {
      fault(func_name, 100);
    }
    
    // Clear results
    eResult.innerHTML = "&nbsp;";
    
    // Get the query word
    e = document.getElementById("txtInput");
    if (e == null) {
      fault(func_name, 110);
    }
    q = e.value;
    
    // Perform the query
    cpa = doQuery(q);
    
    // Build result string
    str = "";
    if (cpa.length > 0) {
      // Matches found, so begin results table
      str = "<table class=\"rtable\">";
      
      // Add each result
      for(i = 0; i < cpa.length; i++) {
        // Get lowercase base-16 of character
        cph = (cpa[i]).toString(16).toLowerCase();
        
        // Add character and codepoint, with codepoint being a link that
        // types the character
        str = str + "<tr><td class=\"han\">";
        str = str + String.fromCodePoint(cpa[i]);
        str = str + "</td><td class=\"cpt\">";
        str = str + "<a href=\"javascript:void ctt_html.typeChar("
        str = str + (cpa[i]).toString(10);
        str = str + ");\">";
        str = str + cph;
        str = str + "</a>";
        
        // Add all readings
        cps = (cpa[i]).toString(10);
        str = str + "</td><td class=\"cpr\">";
        if (cps in m_readings) {
          rra = m_readings[cps];
          if (rra.length > 0) {
            for(k = 0; k < rra.length; k++) {
              if (k > 0) {
                str = str + ", ";
              }
              str = str + rra[k];
            }
            
          } else {
            str = str + "&nbsp;"
          }
          
        } else {
          str = str + "&nbsp";
        }
        
        // Add definition, if available
        str = str + "</td><td class=\"cpd\">";
        if (cph in canto_define) {
          str = str + htmlEsc(canto_define[cph]);
        } else {
          str = str + "&nbsp;";
        }
        
        // Finish row
        str = str + "</td></tr>";
      }
      
      // End results table
      str = str + "</table>";

    } else {
      // No matches
      str = "<p>No matches found!</p>";
    }

    // Update results
    eResult.innerHTML = str;
  }

  /*
   * Event handler for when the document is fully loaded.
   *
   * This should be registered later.
   */
  function handleLoad() {
    
    var func_name = "handleLoad";
    var e, eErrLine;
    
    // Load the readings table
    loadReadings();
    
    // Add an event handler to the codepoint box that immediately hides
    // the error DIV for codepoints if there is any input
    e = document.getElementById("txtCode");
    if (e == null) {
      fault(func_name, 800);
    }
    
    eErrLine = document.getElementById("divErrLine");
    if (eErrLine == null) {
      fault(func_name, 810);
    }
    
    e.oninput = function(ev) {
      eErrLine.style.display = "none";
    };
    
    // Hide the splash-screen DIV and show the main DIV
    e = document.getElementById("divSplash");
    if (e == null) {
      fault(func_name, 900);
    }
    e.style.display = "none";
    
    e = document.getElementById("divMain");
    if (e == null) {
      fault(func_name, 910);
    }
    e.style.display = "block";
  }

  /*
   * Export declarations
   * ===================
   * 
   * All exports are declared within a global "ctt_html" object.
   */
  window.ctt_html = {
    "appear": appear,
    "dismiss": dismiss,
    "typeChar": typeChar,
    "handleCodebox": handleCodebox,
    "handleQuery": handleQuery,
    "handleLoad": handleLoad
  };

}());

// Register the document loading event
window.onload = ctt_html.handleLoad;

    </script>
  </head>
  <body>
  
    <!-- Screen displayed when JavaScript is disabled -->
    <noscript>
      <h1>Cantotype</h1>
      <p>This web app requires JavaScript to function!</p>
    </noscript>
    
    <!-- Initial splash screen, except when JavaScript disabled -->
    <div id="divSplash">
      Loading web app...
    </div>
    
    <!-- The main program window, shown after page is loaded -->
    <div id="divMain">
      <table id="tblCtl">
        <tr>
          <td>
            <input id="txtInput" type="text"/>
          </td>
        </tr>
        <tr>
          <td id="tdQuery">
            <input type="button" value="Query"
              onclick="ctt_html.handleQuery()"/>
          </td>
        </tr>
      </table>
      <div id="divInputNotes" class="clsNotes">
        <div>
          <u>Input format</u><br/>
          <a href="javascript:void ctt_html.appear('divNotes');">
            [&nbsp;Show&nbsp;]
          </a>
          <a href="javascript:void ctt_html.dismiss('divNotes');">
            [&nbsp;Hide&nbsp;]
          </a>
        </div>
        
        <div id="divNotes">
          
<!-- BEGIN Input notes documentation -->
<p>(1) Enter <span class="hanquote">&#x72d7;</span> to look up that
<b>character</b>.  You may only enter one character.</p>

<p>(2) Enter <span class="tt">u72d7</span> or
<span class="tt">U72D7</span> to look up <b>Unicode codepoint</b>
U+72D7.  At least four base-16 digits must be provided.</p>

<p>(3) Enter <span class="tt">gau2</span> to look up all characters
using that <b>Jyutping</b>.</p>

<p>(4) If the input is not in one of the above three formats, then it is
assumed to be in <b>Yale</b>.</p>

<p><i>Yale diacritics:</i></p>

<p>(A) Yale uses grave accent (&agrave;), acute accent (&aacute;) and
macron (&amacr;).</p>

<p>(B) The first vowel that is not Y must carry the diacritic.</p>

<p>(C) For syllabic M and NG, the M and G letters carry the
diacritic.</p>

<p>(D) You may substitute circumflex (&acirc;) for macron (&amacr;).</p>

<p>(E) You may also use apostrophes as escape codes:</p>

<table id="tblApos">
  <tr>
    <th>Code</th>
    <th>Result</th>
    <th>Meaning</th>
  </tr>
  <tr>
    <td class="tdAposCode">'a</td>
    <td class="tdAposResult">&agrave;</td>
    <td class="tdAposMeaning">Grave accent</td>
  </tr>
  <tr>
    <td class="tdAposCode">a'</td>
    <td class="tdAposResult">&aacute;</td>
    <td class="tdAposMeaning">Acute accent</td>
  </tr>
  <tr>
    <td class="tdAposCode">'a'</td>
    <td class="tdAposResult">&amacr;</td>
    <td class="tdAposMeaning">Macron</td>
  </tr>
</table>

<p>(F) Left single quote and right single quote may be used
interchangeably with apostrophe.</p>

<p>(G) Apostrophe codes are especially useful for syllabic M and NG,
which use obscure letter+diacritic combinations.</p>
            
<!-- END Input notes documentation -->
        </div>
      </div>
      <hr/>
      <div id="divResults">
        &nbsp;
      </div>
      <hr/>
      <div id="divTypeNotes" class="clsNotes">
        <div>
          <u>Typing notes</u><br/>
          <a href="javascript:void ctt_html.appear('divTNotes');">
            [&nbsp;Show&nbsp;]
          </a>
          <a href="javascript:void ctt_html.dismiss('divTNotes');">
            [&nbsp;Hide&nbsp;]
          </a>
        </div>
        
        <div id="divTNotes">

<!-- BEGIN Typing notes documentation -->

<p>(1) You can <b>freely type</b> in the following box and use cut,
copy, paste as usual.</p>

<p>(2) You can <b>search for a specific character</b> using the query
box at the top of this page and then clicking the codepoint number in
the results will automatically append that character to the current
cursor position in this typing box.</p>

<p>(3) You can use the <b>codepoint entry box</b> given after this
typing box to enter a sequence of Unicode codepoints in base-16 format,
with codepoints in the entry box separated by spaces.  (The spaces will
not appear in the output.)  Clicking the "Insert" button will then 
insert all these codepoints at the current cursor position in this
typing box.</p>

<p>(4) Beneath the typing box are <b>Chinese punctuation</b> buttons,
which also have their codepoint values in the box in case you want to
use them in the codepoint entry box.  Space is an ideographic space, and
comma and stop as well as quotation marks are also ideographic
versions.</p>

<p>(5) You can <b>resize</b> both the typing box and the codepoint entry
box by dragging the corner.</p>

<!-- END Typing notes documentation -->        
        </div>
      </div>
      <div class="clsLine"><u>Typing box:</u></div>
      <textarea id="txtWrite" rows="5" cols="20"></textarea>
      <div class="clsLine">
        <input type="button" value="Space (3000)"
          onclick="ctt_html.typeChar(0x3000)"/>
        <input type="button" value="Comma (3001)"
          onclick="ctt_html.typeChar(0x3001)"/>
        <input type="button" value="Stop (3002)"
          onclick="ctt_html.typeChar(0x3002)"/>
      </div>
      <div class="clsLine">
        <input type="button" value="Open quote (300C)"
          onclick="ctt_html.typeChar(0x300c)"/>
        <input type="button" value="Close quote (300D)"
          onclick="ctt_html.typeChar(0x300d)"/>
      </div>
      <div class="clsLine"><u>Codepoint entry box:</u></div>
      <textarea id="txtCode" rows="5" cols="20"></textarea>
      <div id="divErrLine">
        ERROR: Invalid codepoint input!
      </div>
      <div class="clsLine">
        <input type="button" value="Insert"
          onclick="ctt_html.handleCodebox()"/>
      </div>
      <hr/>
      <div><i>Cantotype</i></div>
    </div>
  </body>
</html>
